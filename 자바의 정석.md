# 자바의 정석

## 2. 변수
- 기본형: 실제 값(data)를 저장 -> 자료형
  boolean, char, byte, short, __int__, long, float, __double__

- 참조형: 어떤 값이 저장되어 있는 주소(memory address)를 값으로 가짐 -> 타입
- 변환방법
  * 숫자 -> 문자 : (char)(3 + '0') -> '3'
  * 문자 -> 숫자 : '3' - '0' -> 3
  * 숫자 -> 문자열 : 3 + "" -> "3"
  * 문자열 -> 숫자 : Integer.parseInt("3") -> 3 / Double.parseDouble("3.14") -> 3.14
  * 문자열 -> 문자 : "3".charAt(0) -> '3'
  * 문자 -> 문자열 : '3' + "" -> "3"

  
## 3. 연산자
- 형변환 연산자 : 변수 or 상수의 타입을 다른 타입으로 변환하는 것
  * int -> char : (char)65 -> 'A' \n
  * char -> int : (int)'A' -> 65
  * float -> int : (int)1.6f -> 1
  * int -> float : (float)10 -> 10.0f
 
- 산술 변환 : 피연산자의 타입이 다르면 큰 타입으로 일치시킴, int보다 작으면 int로 변환됨
  * byte의 경우 int로 변환되어 계산되지만, 마지막에 형변환 연산자를 사용해서 변환해줘야 컴파일 에러가 생기지 않음. -> (byte)(a * b)
    
- Math.round 반올림 / 완벽하게 상수로 정의하려면 final


## 5. 배열
- String클래스는 char배열에 기능(메서드)을 추가한 것
  * 따라서 String을 사용하는 게 좀 더 편리, 하지만 char배열과 달리 String객체는 읽을 수만 있고 변경할 수 없음
  * char[] toCharArray - 문자열을 char[]로 변환
    
- 2차원 배열 int[][] : [행 수]][열 수]
- 배열의 복사 : Arrays.copyOf(복사할 배열, 복사할 인덱스(0부터)) / Arrays.copyOfRange(복사할 배열, 복사할 시작인덱스, 복사할 마지막 인덱스 + 1)

## 6. 객체지향 프로그래밍
- 코드의 재사용성이 높음, 드의 관리가 용이함, 신뢰성이 높은 프로그래밍 가능하게 함
- 클래스가 제품의 설계도라면, 인스턴스(객체)는 설계도로 만든 제품
- public class의 이름 = 소스파일의 파일명 / public class는 소스파일 내에 하나만
- 변수의 선언 위치 중요! 멤버변수를 제외한 나머지 변수는 지역변수, 멤버변수 중 static이 붙은 건 클래스 변수, 붙지 않은 건 인스턴스 변수
  * 인스턴스 변수 : 클래스 영역에 선언, 인스턴스마다 독립적인 저장공간을 가짐
  * 클래스 변수 : 인스턴스 변수 앞에 static만 붙이면 됨. 모든 인스턴스가 공통된 저장공간(변수)를 공유하게 됨
  * 지역변수 : 메서드 내에 선언되어 메서드 내에서만 사용 가능
  ``` java
  class Variables {
    int iv; // 인스턴스 변수
    static int cv; // 클래스 변수(공유변수)

    void method() {
      int lv = 0; // 지역변수
    }
  }
  ```
- 반환타입이 없으면 void!, 반환값이 있는 경우에는 반드시 return문이 있어야됨
- static을 언제 붙여야 할까?
  * 클래스를 설계할 때, 모든 인스턴스에 공통으로 사용하는 변수에
  * 클래스 변수는 인스턴스를 생성하지 않아도 사용 가능
  * 클래스 메서드는 인스턴스 변수를 사용할 수 없음
  * 메서드 내에서 인스턴스 변수를 사용하지 않는다면
    
- 인스턴스 -> static 호출 가능 / static -> 인스턴스 호출 불가능
- 생성자 : 클래스의 이름과 같아야 함, 리턴 값 없음 - 인스턴스 생성 후에 초기화해주는 기능 (생성하는 건 아님, 생성하는 건 연산자 new)
  * 기본 생성자 : 클래스이름() {} - 클래스에서 정의된 생성자가 하나도 없을 때만 컴파일러에 의해서 자동으로 추가됨
  * this() : 생성자 메서드 첫줄에 호출, 같은 클래스의 다른 생성자를 호출할 때 사용
  * this : 참조변수로 인스턴스 자신을 가리킴, 인스턴스 멤버만 사용 가능 (static은 X)
    
- 지역변수를 사용하기 전에 반드시 초기화해야됨
- 멤버변수의 초기화
  * 클래스변수 초기화 -> 인스턴스 변수 초기화
  * 자동 초기화 -> 명시적 초기화(간단) -> 초기화 블럭, 생성자(복잡)
    
- 상속 : 자손 클래스는 조상 클래스의 모든 멤버를 상속받음 (생성자 & 초기화 블럭은 상속 X), 자손 클래스 멤버 개수 >= 조상 클래스 멤버 개수, 조상은 하나만 허용
  * super : 자손에서 조상으로부터 상속받은 멤버를 참조하는 데 사용되는 사용변수 (조상과 자손의 멤버명이 다를 때)
  * super() : 조상클래스의 생성자
    
- 클래스 간의 관계 결정 : 상속 ? 포함 ?
  * ~은 ~이다 -> 상속
  * ~은 ~을 가지고 있다 -> 포함
    
- 오버라이딩 : 조상에게 상속받은 메서드를 변경하는 것, 메서드의 선언부는 조상의 것과 완전 일치해야 함 (접근 제어자, 예외만 제한 조건 하에서 변경가능)
  * 선언부가 조상의 메서드와 일치해야 함
  * 접근 제어자를 조상의 메서드보다 좁은 범위로 변경할 수 없음 (public > protected > (default) > private)
  * 예외는 조상의 메서드보다 많이 선언할 수 없음
    
- 제어자 : 클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여함
  * static : 공통적인 값을 가짐 -> 멤버변수, 메서드, 초기화 블럭에 사용 가능
  * final : 변경될 수 없는 값이 됨 -> 변수는 상수로, 메서드는 오버라이딩 불가로, 클래스는 확장 불가로 (모든 대상에 사용 가능)
  * abstract : 추상적인 메서드가 존재한다는 걸 알림 -> 클래스, 메서드에 사용 가능
    
- 접근 제어자 : 멤버, 클래스에 사용, 해당 멤버나 클래스를 외부에서 접근하지 못하도록 제한하는 역할 -> 클래스, 멤버변수, 메서드, 생성자에 사용 가능
  * private : 같은 클래스 내에서만 접근 가능
  * (default) : 같은 패키지 내에서만 접근 가능
  * protected : 같은 패키지 내에서, 자손클래스에서 접근 가능
  * public : 접근 제한 없음
    
- 다형성 : 조상 타입 참조 변수로 자손 타입 객체를 다루는 것 (ex/ Tv t = new SmartTv();)
  * 리모컨을 예시로 있는 기능에 해당하는 버튼이 없는 건 괜찮지만, 있는 버튼에 기능이 없는 건 안됨
    
- 참조변수의 형변환 : 사용할 수 있는 멤버의 개수를 조절하는 것, 조상-자손 관계의 참조변수는 서로 형변환 가능 (리모컨 버튼 개수를 바꾼다 생각, SmartTv -> Tv 로 형변환해도 모든 기능을 호출할 순 없음)
- A instanceof B == true -> A는 B로 형변환 가능
- 매개변수의 다형성 : 참조형 매개변수는 메서드 호출 시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있음
- 추상클래스 -> 미완성 설계도 , 인터페이스 -> 기본 설계도
- 인터페이스 : 일반 메서드나 멤버변수를 구성원으로 가질 수 없음
  * 모든 멤버변수는 public static final 이어야 함, 생략 가능
  * 모든 메서드는 public abstract 이어야 함 (static, default는 제외), 생략 가능
  * 인터페이스는 인터페이스로부터만 상속받을 수 있음, 다중상속 가능
  * 인터페이스를 확장하는 클래스를 작성할 때에는 class 클래스이름 __implements__ 인터페이스이름, 인터페이스의 메서드 중 일부만 구현한다면 맨 앞에 abstract 붙여서 추상클래스고 선언
  * 클래스를 상속받아서 인터페이스를 구현할 수도 있음, class 자손클래스이름 __extends__ 조상클래스이름 __implements__ 인터페이스이름
    
- __리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것__
- 인터페이스의 장점
  * 개발시간 단축
  * 표준화 가능
  * 무관한 클래스들에게 관계를 만들어줄 수 있음
  * 독립적인 프로그래밍 가능

- 내부 클래스 : 변수랑 같은 속성, 해당 변수의 자리에 똑같이 해당 클래스를 사용할 수 있음, static멤버는 static클래스에서만 가능  

## 9. java.lang 패키지
- Object 클래스의 메서드
  * protected Object clone() : 객체 자신의 복사본 반환
  * __public boolean equals(Object obj)__ : 객체 자신과 객체 obj가 같으면 true
  * public Class getClass() : 객체 자신의 클래스 정보를 담고있는 클래스 인스턴스를 반환
  * __public int hashCode()__ : 객체 자신의 해시코드 반환
  * __public String toString()__ : 객체 자신의 정보를 문자열로 반환
  * public void notify() : 객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨움
  * public void notifyAll() : 객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨움
  * public void wait() : 다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히, 또는 지정된 시간동안 기다리게 함
 
- StringBuffer : String의 내용을 변경할 때 용이함 -> 멀티쓰레드로 작성된 프로그램이 아닌경우 StringBuilder 사용
  * 두 개 다 같은 StringBuffer인스턴스를 가리키고 있기 때문에 같은 내용이 출력 -> sb.append("123").append("ZZ"); 로 표현 가능
    ``` java
    StringBuffer sb = new StringBuffer("abc");
    sb.append("123");
    StringBuffer sb2 = sb.append("ZZ");
    System.out.println(sb); // abc123ZZ 
    System.out.println(sb2); // abc123ZZ
    ```
  
  * StringBuffer클래스는 equals메서드를 오버라이딩하지 않아서, equals연산자와 ==연산자의 결과가 같음
    ``` java
    StringBuffer sb = new StringBuffer("abc");
    StringBuffer sb2 = new StringBuffer("abc");
    String s = sb.toString();
    String s2 = sb2.toString();
    System.out.println(sb == sb2); // false
    System.out.println(sb.equals(sb2)); // false
    System.out.println(s == s2); // false
    System.out.println(s.equals(s2)); // true
    ```

  * StringBuffer에만 있는 추가, 변경, 삭제 메서드 : append, delete, deleteCharAt, insert, reverse, setCharAt, setLength
    
- Math클래스의 메서드 : abs, ceil, floor, max, min, random, rint, round
- Wrapper클래스 : 기본형 값을 객체로 변환, equals가 오버라이딩 됨 (주소값이 아닌 객체값을 비교), 비교연산자 대신 compareTo
  * 문자열 -> 기본형 : 타입.parse타입(문자열)
  * 문자열 -> 래퍼클래서 : 타입.valueOf(문자열)

## 10. Calendar & Date
- Calender는 추상클래스이기 때문에 직접 메서드를 호출할 수 없고, 인스턴스를 얻어야 한다.
  * Calendar cal = new Calendar(); -- (X)
  * Calendar cal = Calendar.getInstance(); -- (O)
    
- java.text.*;
  * DecimalFormat : 의미를 가진 패턴으로 숫자 형식화 가능
  * SimpleDateFormat : 패턴으로 날짜 형식화 가능

## 11. 컬렉션 프레임웍
- 핵심 인터페이스 : 특징과 차이를 잘 이해하고 있어야 함
  * List : ArrayList, LinkedList, Stack, Vector 등 순서(O) 데이터 중복(O) / ex 대기자 명단
  * Set : HashSet, TreeSet 등 순서(X) 데이터 중복(X) / ex 양의 정수집합, 소수의 집합
  * Map : HashMap, TreeMap, Hashtable, Properties 등 key & value가 한 쌍으로 이루어진 데이터의 집합, 순서(X) 키 중복(X) 값 중복(O) / ex 우편번호, 지역번호
    
- ArrayList vs LinkedList -> 다루고자 하는 데이터의 개수가 변하지 않는 경우라면 ArrayList, 개수 변경이 잦다면 LinkedList
  * ArrayList : 접근시간 빠름, 추가삭제 느림, 순차적인 추가삭제는 빠름, 메모리사용 비효율적
  * LinkedList : 접근시간 느림, 추가삭제 빠름, 데이터가 많으면 접근성 떨어짐

- Stack & Queue
  * Stack : 마지막에 저장한 데이터를 먼저 꺼냄, 아래부터 순차적으로 쌓이고 위부터 꺼냄 -> ArrayList 적합
  * Queue : 먼저 저장한 데이터부터 꺼냄, 아래부터 순차적으로 쌓이고 아래부터 꺼냄 -> LinkedList 적합
 
- 컬렉션에 저장된 요소를 접근하는 데에 사용되는 인터페이스, Enumeration > Iterator > ListIterater(List구현 시 양방향 조회기능추가) 순으로 향상
- Iterator를 이용해서 읽어오면 List클래스들은 저장순서와 동일하게 불러와지지만, Set클래스들은 순서 유지가 되지 않기 때문에 저장순서와 같지 않음
- Arrays의 메서드
  * 복사 : copyOf, copyOfRange
  * 채우기: fill, setAll
  * 정렬 : sort
  * 검색 : binarySearch
  * 비교 : equals, deepToEquals
  * 출력 : toString, deepToString
  * 변환 : asList -> 리스트의 크기는 변경 불가, 추가삭제 불가, 내용변경은 가능

- Comparator & Comparable : Arrays.sort()는 배열을 정렬할 때, Comparator를 지정해주지 않으면 Comparable을 구현한 클래스의 객체의 내용에 따라 정렬됨
  * Comparator : 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용
  * Comparable : 기본 정렬기준을 구현하는 데 사용
  * Integer : 두 Integer객체에 저장된 value값을 비교해서 같으면 0, 크면 -1, 작으면 1 반환 -> 정렬기준에 -1만 곱해주면 역순정렬

- HashSet : 정렬(X) 중복(X) 순서를 유지하려면 LinkedHashSet 사용
  * 객체를 저장하기 전에 기존에 같은 객체가 있는지 확인 후, 같은 객체가 없으면 저장하고 있으면 저장하지 않음
  * boolean add(Object obj)는 저장할 객체의 equals()와 hashCode()를 호출 -> 오버라이딩 되어있어야 함
   
- TreeSet & TreeMap : 정렬(O) 중복(X)
  * 이진 탐색 트리  
    - 데이터가 많아질수록 추가, 삭제에 시간이 더 걸림 (비교 횟수 증가)
    - 최대 두 개의 자식노드
    - 부모보다 작은 값은 왼쪽, 큰 값은 오른쪽에 저장
    - 범위 검색과 정렬에 유리

- HashMap & Hashtable : 순서(X) 키 중복 (X) 값 중복 (O), 순서를 유지하려면 LinkedHashMap 사용
  * 해싱기법으로 데이터를 저장, 데이터가 많아도 검색이 빠름
  * Map인터페이스를 구현, 데이터를 키와 값의 쌍으로 저장
  * 해시테이블 : 배열과 링크드리스트가 조합된 형태 (접근성 + 변경용이)
  * 해시코드 : 배열의 인덱스
 
- Collections의 메서드
  * 동기화 : synchronizedXXX() -> List syncList = Collections.synchronizedList(new ArrayList(...));
  * 변경불가 : unmodifiableXXX()
  * 싱글톤 : singletonXXX(), 객체 한 개만 저장
  * 단일 컬렉션 : checkedXXX(), 한 종류의 객체만 저장


## 12. 지네릭스, 열거형, 애너테이션
- 지네릭스 : 객체의 타입을 컴파일 시에 체크, 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어듦, 타입체크와 형변환을 생략할 수 있어 코드가 간결해짐 
  * ArrayList<E> -> Element타입 객체 변수
  * ArrayList<Tv> -> Tv타입 객체를 대입, E에 Tv대입
  * 객체별로 다른 타입을 지정하는 것은 적절, static멤버에는 타입변수 사용 불가, 지네릭 타입의 배열 생성 불가

- 와일드 카드 : 지네릭 타입에 다형성을 적용, 하나의 참조변수로 다른 지네릭 타입이 지정된 객체를 다룰 수 있음
  * <? extends T> - 와일드 카드의 상한 제한, T와 그 자손들만 가능
  * <? extends T> - 와일드 카드의 하한 제한, T와 그 조상들만 가능
  * <?> - 제한 없음, 모든 타입이 가능 (<? extends Objeck>와 동일)

- 지네릭 메서드 : 메서드의 선언부에 지네릭 타입이 선언된 메서드
  * 지네릭 클래스에 정의된 타입 매개변수 T != 지네릭 메서드에 정의된 타입 매개변수 T
  * static멤버에는 타입 매개변수를 사용할 수 없지만, 메서드에 지네릭 타입을 선언하고 사용하는 건 가능 (ex / Collections.sort() -> Collections는 지네릭 타입, sort()는 static 메서드)
    
